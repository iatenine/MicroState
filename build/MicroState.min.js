"use strict";function _callSuper(a,b,c){return b=_getPrototypeOf(b),_possibleConstructorReturn(a,_isNativeReflectConstruct()?Reflect.construct(b,c||[],_getPrototypeOf(a).constructor):b.apply(a,c))}function _possibleConstructorReturn(a,b){if(b&&("object"===_typeof(b)||"function"==typeof b))return b;if(void 0!==b)throw new TypeError("Derived constructors may only return object or undefined");return _assertThisInitialized(a)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _isNativeReflectConstruct(){try{var a=!Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){}))}catch(a){}return(_isNativeReflectConstruct=function(){return!!a})()}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf.bind():function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),Object.defineProperty(a,"prototype",{writable:!1}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _slicedToArray(a,b){return _arrayWithHoles(a)||_iterableToArrayLimit(a,b)||_unsupportedIterableToArray(a,b)||_nonIterableRest()}function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _iterableToArrayLimit(b,c){var d=null==b?null:"undefined"!=typeof Symbol&&b[Symbol.iterator]||b["@@iterator"];if(null!=d){var g,h,j,k,l=[],a=!0,m=!1;try{if(j=(d=d.call(b)).next,0===c){if(Object(d)!==d)return;a=!1}else for(;!(a=(g=j.call(d)).done)&&(l.push(g.value),l.length!==c);a=!0);}catch(a){m=!0,h=a}finally{try{if(!a&&null!=d["return"]&&(k=d["return"](),Object(k)!==k))return}finally{if(m)throw h}}return l}}function _arrayWithHoles(a){if(Array.isArray(a))return a}function _toConsumableArray(a){return _arrayWithoutHoles(a)||_iterableToArray(a)||_unsupportedIterableToArray(a)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}function _unsupportedIterableToArray(a,b){if(a){if("string"==typeof a)return _arrayLikeToArray(a,b);var c=Object.prototype.toString.call(a).slice(8,-1);return"Object"===c&&a.constructor&&(c=a.constructor.name),"Map"===c||"Set"===c?Array.from(a):"Arguments"===c||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(c)?_arrayLikeToArray(a,b):void 0}}function _iterableToArray(a){if("undefined"!=typeof Symbol&&null!=a[Symbol.iterator]||null!=a["@@iterator"])return Array.from(a)}function _arrayWithoutHoles(a){if(Array.isArray(a))return _arrayLikeToArray(a)}function _arrayLikeToArray(a,b){(null==b||b>a.length)&&(b=a.length);for(var c=0,d=Array(b);c<b;c++)d[c]=a[c];return d}function _typeof(a){"@babel/helpers - typeof";return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function ownKeys(a,b){var c=Object.keys(a);if(Object.getOwnPropertySymbols){var d=Object.getOwnPropertySymbols(a);b&&(d=d.filter(function(b){return Object.getOwnPropertyDescriptor(a,b).enumerable})),c.push.apply(c,d)}return c}function _objectSpread(a){for(var b,c=1;c<arguments.length;c++)b=null==arguments[c]?{}:arguments[c],c%2?ownKeys(Object(b),!0).forEach(function(c){_defineProperty(a,c,b[c])}):Object.getOwnPropertyDescriptors?Object.defineProperties(a,Object.getOwnPropertyDescriptors(b)):ownKeys(Object(b)).forEach(function(c){Object.defineProperty(a,c,Object.getOwnPropertyDescriptor(b,c))});return a}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,_toPropertyKey(c.key),c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),Object.defineProperty(a,"prototype",{writable:!1}),a}function _defineProperty(a,b,c){return b=_toPropertyKey(b),b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}function _toPropertyKey(a){var b=_toPrimitive(a,"string");return"symbol"==_typeof(b)?b:b+""}function _toPrimitive(a,b){if("object"!=_typeof(a)||!a)return a;var c=a[Symbol.toPrimitive];if(void 0!==c){var d=c.call(a,b||"default");if("object"!=_typeof(d))return d;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===b?String:Number)(a)}/**
 * Palau
 * Singleton class to manage page state and Tuvalu component injection
 * Components passed in Constructor will be rendered automatically
 * and only updated when pageState keys found in their listen array
 * are updated
 * @dependency Tuvalu
 */var Palau=/*#__PURE__*/function(){function Palau(){_classCallCheck(this,Palau)}return _createClass(Palau,null,[{key:"init",value:/**
     * initialize page state and mount/subscribe components.
     * Component states will be derived from the pageState object
     * and only include keys found in their listen array
     * @param {{
     * pageState: object,
     * components: {
     * rootComponent: TuvaluComponent,
     * mountPoint: HTMLElement,
     * listens?: string[],
     * }[]
     * }} pageState
     */function(a){var b=a.pageState,c=void 0===b?{}:b,d=a.components,e=void 0===d?[]:d;if(this.instantiated)throw new Error("Palau has already been instantiated. Use Palau.putPageState() to manage state");if(c!==Object(c))throw new Error("pageState must be an object if specified");if(!Array.isArray(e))throw new Error("components must be an array");e.forEach(function(a){if(!a.rootComponent||!a.mountPoint)throw new Error("Invalid component configuration: mountPoint and root are required in each component")}),Palau.pageState=c,e.forEach(function(a,b){a.listens||(a.listens=[]),Palau.subcribedEvents[a.listens]||(Palau.subcribedEvents[a.listens]=[]),Palau.subcribedEvents[a.listens].push(b);var c=Palau.__listenerStringsToObject(a.listens);a.state=_objectSpread({},c),Palau.components.push({component:new Tuvalu(a),listens:a.listens})}),this.instantiated=!0}/**
     * Return pageState object, or specific key if provided
     * keys can specify nested values such as "list[0].name"
     * @param {string} key?
     * @returns
     */},{key:"getPageState",value:function(){var key=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;if(null===key||"string"!=typeof key)return Palau.pageState;var executionString=Palau.__convertKeyToExecutionString(key);return eval(executionString)}/**
     * update state of keys present in newState object
     * and re-render subscribed components. Unlisted keys
     * will not be updated
     * @param {object} newState
     * @returns
     */},{key:"putPageState",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;if(null===a)return void console.warn("putPageState called with null value. Ignoring.");var b=Object.keys(a);// Prevent unnecessary re-renders
b.forEach(function(c){Palau.pageState[c]===a[c]&&(b.splice(b.indexOf(c),1),delete a[c])});try{Palau.__setPageState(_objectSpread(_objectSpread({},Palau.pageState),a));var c=[];b.forEach(function(a){var b=Palau.subcribedEvents[a]||[];b.forEach(function(a){c.includes(a)||c.push(a)})}),c.forEach(function(a){var b=Palau.__listenerStringsToObject(Palau.components[a].listens);Palau.components[a].component._setState(b)})}catch(b){var d={message:b.message,stack:b.stack,pageState:Palau.pageState,newState:a};throw console.error(d),new Error("Failed to update pageState: "+d.message)}}/**
     * private function, do not invoke directly
     * update pageState with new state object. This is a destructive operation
     * that will not trigger a re-render of the component. Use putPageState()
     * instead when possible.
     * @param {object} state
     * @returns
     */},{key:"__setPageState",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;if(null===a)return void console.warn("setPageState called with null value. Ignoring.");if("object"!==_typeof(a))throw new Error("setPageState requires an object");dispatchEvent(new Event("updatePalauState:",{prevState:Palau.pageState,state:a})),Palau.pageState=a}/**
     * private function, do not invoke directly
     * Provided a string, returns a string that can be evaluated to access the
     * value of the key in the pageState object. If excludePageState is true,
     * the string will be returned without the pageState prefix. Example:
     * "list[0].name" => "Palau.pageState['list'][0]['name']"
     * @param {string} key
     * @param {boolean} excludePageState
     * @returns {string}
     */},{key:"__convertKeyToExecutionString",value:function(a){var b=!!(1<arguments.length&&void 0!==arguments[1])&&arguments[1],c=a.match(/[\d+]/g),d=a.split(".").map(function(a){return a.split(/[\d+]/)}).flat(),e=d.map(function(a){return"]"===a?parseInt(c.pop()):a.endsWith("[")?a.slice(0,-1):a}),f=e.map(function(a){return"string"==typeof a?"[\""+a+"\"]":"["+a+"]"}).join("");return b?"".concat(f):"Palau.pageState".concat(f)}/**
     * private function, do not invoke directly
     * Provided an array of strings, returns an object with matching keys,
     * populating the values with the current state of the page. Until nested
     * listeners are supported, only Object.keys() is needed for the inverse
     * @param {string[]} strings
     * @returns {object}
     */},{key:"__listenerStringsToObject",value:function(strings){var result={},uniqueStrings=_toConsumableArray(new Set(strings));return uniqueStrings.forEach(function(string){var executionString=Palau.__convertKeyToExecutionString(string,!0),key=executionString.replace("]","").replace("[","").replace(/"/g,"");result[key]=eval("this.pageState".concat(executionString))}),result}}]),Palau}();/**
 * Nauru
 * Helper class to manage event listeners between renders
 */_defineProperty(Palau,"pageState",{}),_defineProperty(Palau,"components",[]),_defineProperty(Palau,"subcribedEvents",{}),_defineProperty(Palau,"instantiated",!1);var Nauru=/*#__PURE__*/function(){function a(){_classCallCheck(this,a)}return _createClass(a,null,[{key:"useListener",value:/**
     * Accepts an array of objects with the following structure:
     * {
     *  callback: (e) => any,
     * name: string,
     * }
     * and returns a string to be used as a tag in the component's HTML
     * example: <button ${tag}>Click Me!</button>
     * @param {{name: string, callback: () => any}[]} newEvents
     * @returns {string} tag
     */function(b){return a.events.push(b),"data-nauru=".concat(a.count++)}},{key:"_attachListeners",value:function(){var b=document.querySelectorAll("[data-nauru]");b.forEach(function(b){var c=b.dataset.nauru,d=a.events[c];d.forEach(function(a){b.addEventListener(a.name,a.callback)})})}}]),a}();/**
 * Tuvalu
 * A state container to render HTML strings returned by components,
 * injected into a DOM element provided upon instantiation. Manual instantiation
 * is not required, consider using Palau instead
 */_defineProperty(Nauru,"count",0),_defineProperty(Nauru,"events",[]);var Tuvalu=/*#__PURE__*/function(){/**
   * @param {{
   * rootComponent: (contextObject: {
   *  state: object,
   *  prevState: object | null,
   *  useListener: (event: Event) => any,
   *  props: object,
   * }) => string,
   * state?: object,
   * mountPoint?: HTMLElement}} Config
   */function Tuvalu(a){var b=a.rootComponent,c=a.state,d=void 0===c?{}:c,e=a.mountPoint,f=void 0===e?null:e;if(_classCallCheck(this,Tuvalu),!f)throw new Error("mountPoint must be provided");if(!b)throw new Error("rootComponent is required");this._setState(d),this.root=b,this.onAfterRender=function(){},this.onBeforeRender=function(){},this.mountPoint=f,this._render()}/**
   * Return state object if no key is provided or
   * state[key] if it is
   * @param {string} key
   * @returns {object}
   */return _createClass(Tuvalu,[{key:"_getState",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;return null===a?this.state:this.state[a]}/**
     * overwrites state with provided object.
     * If only looking to update one key, consider putState()
     * @param {object} state
     */},{key:"_setState",value:function(a){var b=_objectSpread({},this.state);this.state=Tuvalu.escapeHTML(a),this._render(b)}/**
     * Updates keys specified in provided newState object with new values
     * @param {object} newState
     */},{key:"putState",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};try{this._setState(_objectSpread(_objectSpread({},this.state),a))}catch(c){var b={message:c.message,stack:c.stack,state:this.state,newState:a};throw new Error("Failed to update state: ",b)}}/**
     * private function, do not invoke directly
     * Set callback to occur before updating mount point's innerHTML
     * @param {Function} callback
     */},{key:"_setOnBeforeRender",value:function(a){this.onBeforeRender=a,this._render(this.state)}/**
     * private function, do not invoke directly
     * Set callback to occur after updating mount point's innerHTML
     * @param {Function} callback
     */},{key:"_setOnAfterRender",value:function(a){this.onAfterRender=a,this._render(this.state)}/**
     * private function, do not invoke directly
     * @param {string} mountPointId
     */},{key:"_mount",value:function(a){this.mountPoint=document.getElementById(a),this._render()}/**
     * private function, do not invoke directly
     * @param {object} prevState
     * @returns {void}
     */},{key:"_render",value:function(a){if(this.root&&this.mountPoint){this.onBeforeRender(this.state,a);var b=this.root({state:this.state,prevState:a,props:{}}),c=this._evaluateString(b,this.state,a);this.mountPoint.innerHTML=c,Nauru._attachListeners(),this.onAfterRender(this.state,a)}}/**
     * private function, do not invoke directly
     * @param {string} string
     * @param {object} state
     * @param {object} prevState
     * @returns {string} HTML string
     */},{key:"_evaluateString",value:function(string,state,prevState){var regex=/<[A-Z]\w*.*?\/>/;// base case, return string if regex doesn't match anything
if(!string.match(regex))return string;// otherwise, get the first match and evaluate it
var match=string.match(regex)[0],componentName=match.match(/\w+/g)[0],props=match.match(/\w+={[^}]*}+/)?this._buildObjectFromAttributes(match):{},executionString="".concat(componentName,"({\n      state: ").concat(JSON.stringify(state),", \n      prevState: ").concat(JSON.stringify(prevState),",\n      ...").concat(JSON.stringify(props),",\n      })"),replacementString=eval(executionString),trimOuter=/<([A-z]*)[^>]*>(\s|.)*?<\/(\1)>/g;return this._evaluateString(string.replace(regex,replacementString),state,prevState).match(trimOuter).join("")}/**
     * private function, do not invoke directly
     * @param {string} string
     * @returns
     */},{key:"_buildObjectFromAttributes",value:function(a){// expect component to have the following form <ComponentName key1={value1} key2={value2} />
var b=a.match(/\w+={[^}]*}/g),c={};return b?(b.forEach(function(a){var b=a.split(/\s*=\s*/),d=_slicedToArray(b,2),e=d[0],f=d[1];c[e]=f.slice(1,-1)}),c):c}/**
     * Accepts state object and recursively escapes all values
     * with type of string of HTML characters.
     * @param {string} state
     * @returns {object}
     */}],[{key:"escapeHTML",value:function(a){// recursively escapeHTML of all strings in state
for(var b=Object.keys(a),c=0,d=b;c<d.length;c++){var e=d[c],f=a[e];("object"===_typeof(f)||"array"==typeof f)&&(a[e]=Tuvalu.escapeHTML(f)),"string"==typeof f&&(a[e]=Tuvalu.sanitizeHTML(f))}return a}/**
     * Accepts a string and escapes all HTML characters
     * @param {string} unsafe
     * @returns {string}
     */},{key:"sanitizeHTML",value:function(a){return a.replace(/&(?!(amp;|lt;|gt;|#39;|quot;))/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/'/g,"&#39;").replace(/"/g,"&quot;")}}]),Tuvalu}(),MicroState=/*#__PURE__*/function(a){function b(a){var c=a.rootComponent,d=a.state,e=void 0===d?{}:d,f=a.mountPoint,g=void 0===f?null:f;return _classCallCheck(this,b),g||(g=document.querySelector("#root")),_callSuper(this,b,[{rootComponent:c,state:e,mountPoint:g}])}return _inherits(b,a),_createClass(b,[{key:"getState",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:null;return this._getState(a)}},{key:"setState",value:function(a){this._setState(a)}}]),b}(Tuvalu);/**
 * MicroState
 * A subclass of Tuvalu created to ensure backwards compatibility
 * Not recommended to use in new projects. Refer to documentation for
 * current best practices
 */